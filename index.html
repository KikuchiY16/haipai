<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éº»é›€é…ç‰Œ å‹ç‡äºˆæ¸¬AI</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        body { font-family: sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }
        textarea { width: 100%; height: 80px; margin-bottom: 10px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; }
        button:disabled { background-color: #ccc; }
        #result { margin-top: 20px; font-size: 24px; font-weight: bold; }
        .note { font-size: 12px; color: #666; }
    </style>
</head>
<body>

    <h1>ğŸ€„ éº»é›€é…ç‰Œ å‹ç‡äºˆæ¸¬AI</h1>
    <p>å¤©é³³ã®é…ç‰ŒIDï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚</p>
    
    <textarea id="handInput" placeholder="ä¾‹: 11,12,13,45,46,47,88,89..."></textarea>
    <br>
    <button id="predictBtn" onclick="runPrediction()">äºˆæ¸¬ã™ã‚‹</button>

    <div id="result">ã“ã“ã«çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
    
    <p class="note">â€»åˆå›ã¯ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã«æ•°ç§’ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</p>

    <script>
        // ONNXãƒ¢ãƒ‡ãƒ«ã®ãƒ‘ã‚¹ (åŒã˜éšå±¤ã«ç½®ã„ã¦ã‚ã‚‹å‰æ)
        const MODEL_PATH = './mahjong_model.onnx';
        let session = null;

        // 1. ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
        async function loadModel() {
            try {
                document.getElementById('result').innerText = "ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...";
                // æ¨è«–ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ä½œæˆ
                session = await ort.InferenceSession.create(MODEL_PATH);
                document.getElementById('result').innerText = "æº–å‚™å®Œäº†ã€‚é…ç‰Œã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚";
                console.log("Model loaded successfully");
            } catch (e) {
                console.error(e);
                document.getElementById('result').innerText = "ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ (è©³ç´°ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«)";
            }
        }

        // 2. å…¥åŠ›æ–‡å­—åˆ—ã‚’AIç”¨ã®ãƒ™ã‚¯ãƒˆãƒ«ã«å¤‰æ› (Pythonã®vectorize_hand_tensorã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯)
        function textToVector(text) {
            // 35å€‹ã®ã‚¼ãƒ­é…åˆ—
            const counts = new Int32Array(35).fill(0);
            
            if (!text) return counts;

            const ids = text.split(',').map(s => parseInt(s.trim()));
            
            for (let tid of ids) {
                if (isNaN(tid)) continue;

                // ç‰Œã®ç¨®é¡ (0~33)
                let type = Math.floor(tid / 4);
                if (type >= 0 && type < 34) {
                    counts[type]++;
                }
                // èµ¤ãƒ‰ãƒ© (16, 52, 88) -> index 34
                if ([16, 52, 88].includes(tid)) {
                    counts[34]++;
                }
            }
            
            // æœ€å¤§4æšåˆ¶é™ (å¿µã®ãŸã‚)
            for(let i=0; i<35; i++) {
                if(counts[i] > 4) counts[i] = 4;
            }
            
            return counts;
        }

        // 3. äºˆæ¸¬å®Ÿè¡Œãƒœã‚¿ãƒ³
        async function runPrediction() {
            if (!session) {
                alert("ãƒ¢ãƒ‡ãƒ«ãŒã¾ã èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“");
                return;
            }

            const text = document.getElementById('handInput').value;
            const inputVector = textToVector(text);

            try {
                // Tensorã®ä½œæˆ
                // Pythonã§ã®å‹ã¯ Long (int64) ã§ã—ãŸãŒã€ONNX Runtime JSã§ã¯ BigInt64Array ã‚’ä½¿ã†ã‹
                // ãƒ¢ãƒ‡ãƒ«å¤‰æ›æ™‚ã«Int32ã«ã—ã¦ãŠãã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚
                // ä»Šå›ã¯PyTorchã®EmbeddingãŒLongã‚’è¦æ±‚ã™ã‚‹ãŸã‚ã€BigInt64Arrayã‚’ä½¿ã„ã¾ã™ã€‚
                const dataBigInt = BigInt64Array.from(Array.from(inputVector).map(n => BigInt(n)));
                const tensor = new ort.Tensor('int64', dataBigInt, [1, 35]);

                // æ¨è«–å®Ÿè¡Œ
                // feeds: input_names ('input') ã« tensor ã‚’æ¸¡ã™
                const feeds = { input: tensor };
                const results = await session.run(feeds);

                // çµæœå–å¾— (output_names 'output')
                const outputData = results.output.data;
                const probability = outputData[0]; // 1ã¤ç›®ã®å€¤

                // è¡¨ç¤º
                const percentage = (probability * 100).toFixed(2);
                document.getElementById('result').innerHTML = `äºˆæ¸¬å‹ç‡: <span style="color:red">${percentage}%</span>`;

            } catch (e) {
                console.error(e);
                alert("äºˆæ¸¬ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e);
            }
        }

        // é–‹å§‹
        loadModel();
    </script>
</body>
</html>