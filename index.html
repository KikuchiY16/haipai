<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éº»é›€é…ç‰Œ å‹ç‡äºˆæ¸¬AI</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; text-align: center; background-color: #f4f4f4; }
        
        h1 { color: #333; }
        
        /* æ‰‹ç‰Œè¡¨ç¤ºã‚¨ãƒªã‚¢ */
        .hand-display {
            background-color: #225522; /* é›€å“ã®è‰² */
            min-height: 60px;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 5px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        .tile {
            width: 40px;
            height: 56px;
            background-color: #fff;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
            user-select: none;
            position: relative;
            color: black;
        }
        
        .tile.man { color: #800000; } /* è¬å­ã¯èµ¤ã£ã½ã */
        .tile.pin { color: #000080; } /* ç­’å­ã¯é’ã£ã½ã */
        .tile.sou { color: #006400; } /* ç´¢å­ã¯ç·‘ã£ã½ã */
        .tile.red { color: red; }     /* ä¸­ãªã© */

        /* ç‰Œã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ */
        .keyboard {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }
        .row {
            display: flex;
            justify-content: center;
            gap: 5px;
            flex-wrap: wrap;
        }

        /* ãƒœã‚¿ãƒ³é¡ */
        .controls { margin: 20px 0; }
        
        button.action-btn {
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background 0.3s;
        }
        button.action-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        button.action-btn:hover:not(:disabled) {
            background-color: #0056b3;
        }

        button.reset-btn {
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            margin-left: 10px;
        }

        /* çµæœãƒ»è­¦å‘Šè¡¨ç¤º */
        #result { margin-top: 20px; font-size: 28px; font-weight: bold; min-height: 40px;}
        #warning { color: red; font-weight: bold; height: 24px; margin-bottom: 5px;}
        
        .loading { color: #666; font-size: 14px; }
    </style>
</head>
<body>

    <h1>ğŸ€„ éº»é›€é…ç‰Œ å‹ç‡äºˆæ¸¬AI</h1>

    <div id="warning"></div>
    <div class="hand-display" id="currentHand">
        </div>

    <div class="controls">
        <button id="predictBtn" class="action-btn" onclick="runPrediction()" disabled>äºˆæ¸¬ã™ã‚‹</button>
        <button class="reset-btn" onclick="resetHand()">ãƒªã‚»ãƒƒãƒˆ</button>
    </div>

    <div id="result"></div>

    <div class="keyboard">
        <div class="row" id="row-man"></div> <div class="row" id="row-pin"></div> <div class="row" id="row-sou"></div> <div class="row" id="row-hon"></div> </div>

    <p class="loading" id="statusMsg">ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...</p>

    <script>
        const MODEL_PATH = './mahjong_model.onnx';
        let session = null;
        
        // é¸æŠã•ã‚ŒãŸç‰Œã®IDãƒªã‚¹ãƒˆ (0~135)
        let selectedHandIds = [];

        // ç‰Œã®å®šç¾© (Unicodeæ–‡å­—ã¨ç¨®é¡)
        const TILES = {
            man: ['ğŸ€‡','ğŸ€ˆ','ğŸ€‰','ğŸ€Š','ğŸ€‹','ğŸ€Œ','ğŸ€','ğŸ€','ğŸ€'], // 1-9è¬
            pin: ['ğŸ€™','ğŸ€š','ğŸ€›','ğŸ€œ','ğŸ€','ğŸ€','ğŸ€Ÿ','ğŸ€ ','ğŸ€¡'], // 1-9ç­’
            sou: ['ğŸ€','ğŸ€‘','ğŸ€’','ğŸ€“','ğŸ€”','ğŸ€•','ğŸ€–','ğŸ€—','ğŸ€˜'], // 1-9ç´¢
            hon: ['ğŸ€€','ğŸ€','ğŸ€‚','ğŸ€ƒ','ğŸ€†','ğŸ€…','ğŸ€„']           // æ±å—è¥¿åŒ—ç™½ç™¼ä¸­
        };

        // åˆæœŸåŒ–å‡¦ç†
        window.onload = async function() {
            createKeyboard();
            await loadModel();
            updateDisplay(); // åˆå›æç”»
        };

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ç”Ÿæˆ
        function createKeyboard() {
            createRow('row-man', TILES.man, 'man', 0);  // è¬å­: type 0-8
            createRow('row-pin', TILES.pin, 'pin', 9);  // ç­’å­: type 9-17
            createRow('row-sou', TILES.sou, 'sou', 18); // ç´¢å­: type 18-26
            createRow('row-hon', TILES.hon, 'red', 27); // å­—ç‰Œ: type 27-33
        }

        function createRow(elementId, chars, colorClass, typeOffset) {
            const container = document.getElementById(elementId);
            chars.forEach((char, index) => {
                const btn = document.createElement('div');
                btn.className = `tile ${colorClass}`;
                btn.innerText = char;
                // ã‚¯ãƒªãƒƒã‚¯æ™‚ã®å‡¦ç†: ãã®ç¨®é¡ã®ç‰Œã‚’è¿½åŠ 
                btn.onclick = () => addTile(typeOffset + index, char, colorClass);
                container.appendChild(btn);
            });
        }

        // ãƒ¢ãƒ‡ãƒ«ãƒ­ãƒ¼ãƒ‰
        async function loadModel() {
            try {
                session = await ort.InferenceSession.create(MODEL_PATH);
                document.getElementById('statusMsg').innerText = "æº–å‚™å®Œäº†";
                console.log("Model loaded");
            } catch (e) {
                console.error(e);
                document.getElementById('statusMsg').innerText = "ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼";
            }
        }

        // ç‰Œã‚’è¿½åŠ ã™ã‚‹å‡¦ç†
        function addTile(typeIndex, char, colorClass) {
            if (selectedHandIds.length >= 14) return; // æœ€å¤§14æšã¾ã§ï¼ˆä¸€å¿œï¼‰

            // typeIndex (0~33) ã‚’ å¤©é³³ID (0~135) ã«ç°¡æ˜“å¤‰æ›
            // ãƒ¢ãƒ‡ãƒ«ã¯ ID//4 ã§ç¨®é¡ã‚’è¦‹ã‚‹ã®ã§ã€å„ç¨®é¡ã®ä¸€ç•ªè‹¥ã„ç•ªå·(type*4)ã‚’ä½¿ãˆã°OK
            // â€»èµ¤ãƒ‰ãƒ©ã‚’å…¥ã‚ŒãŸã„å ´åˆã¯ã“ã“ã§åˆ†å²ãŒå¿…è¦ã§ã™ãŒã€ä»Šå›ã¯é»’5ã«ã—ã¾ã™
            const id = typeIndex * 4; 
            
            selectedHandIds.push({ id: id, char: char, color: colorClass });
            
            // ç†ç‰Œï¼ˆã‚½ãƒ¼ãƒˆï¼‰: IDé †ã«ä¸¦ã¹ã‚‹
            selectedHandIds.sort((a, b) => a.id - b.id);
            
            updateDisplay();
        }

        // æ‰‹ç‰Œè¡¨ç¤ºã®æ›´æ–° & ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        function updateDisplay() {
            const container = document.getElementById('currentHand');
            container.innerHTML = '';

            // æ‰‹ç‰Œã‚’æç”»
            selectedHandIds.forEach((tile, index) => {
                const div = document.createElement('div');
                div.className = `tile ${tile.color}`;
                div.innerText = tile.char;
                // ã‚¯ãƒªãƒƒã‚¯ã§å‰Šé™¤
                div.onclick = () => removeTile(index);
                container.appendChild(div);
            });

            // 13æšãƒã‚§ãƒƒã‚¯
            const count = selectedHandIds.length;
            const warnEl = document.getElementById('warning');
            const btn = document.getElementById('predictBtn');

            if (count === 13) {
                warnEl.innerText = "";
                btn.disabled = false;
            } else {
                warnEl.innerText = `ç¾åœ¨ ${count} æšã§ã™ã€‚13æšã«ã—ã¦ãã ã•ã„ã€‚`;
                btn.disabled = true;
            }
        }

        // ç‰Œã‚’å‰Šé™¤
        function removeTile(index) {
            selectedHandIds.splice(index, 1);
            updateDisplay();
        }

        // ãƒªã‚»ãƒƒãƒˆ
        function resetHand() {
            selectedHandIds = [];
            document.getElementById('result').innerText = "";
            updateDisplay();
        }

        // äºˆæ¸¬å®Ÿè¡Œ
        async function runPrediction() {
            if (!session) return;

            // å…¥åŠ›ãƒ™ã‚¯ãƒˆãƒ«ä½œæˆ (35æ¬¡å…ƒ)
            const counts = new Int32Array(35).fill(0);
            
            selectedHandIds.forEach(tile => {
                // IDã‹ã‚‰ç¨®é¡(0-33)ã‚’å¾©å…ƒ
                const type = Math.floor(tile.id / 4);
                if(type >= 0 && type < 34) {
                    counts[type]++;
                }
                // ä»Šå›ã¯ãƒœã‚¿ãƒ³å…¥åŠ›ãªã®ã§èµ¤ãƒ‰ãƒ©(ID:16,52,88)ã¯å«ã¾ã‚Œãªã„ãŒã€
                // ãƒ­ã‚¸ãƒƒã‚¯ã¨ã—ã¦ã¯æ®‹ã—ã¦ãŠã
                if ([16, 52, 88].includes(tile.id)) {
                    counts[34]++;
                }
            });

            // Tensorä½œæˆ
            try {
                const dataBigInt = BigInt64Array.from(Array.from(counts).map(n => BigInt(n)));
                const tensor = new ort.Tensor('int64', dataBigInt, [1, 35]);

                const feeds = { input: tensor };
                const results = await session.run(feeds);
                const outputData = results.output.data;
                const probability = outputData[0];

                const percentage = (probability * 100).toFixed(2);
                document.getElementById('result').innerHTML = `äºˆæ¸¬å‹ç‡: <span style="color:#d9534f">${percentage}%</span>`;

            } catch (e) {
                console.error(e);
                alert("ã‚¨ãƒ©ãƒ¼: " + e);
            }
        }
    </script>
</body>
</html>